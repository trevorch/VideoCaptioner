#!/usr/bin/env python3
"""
ASR命令行工具 - 视频文件语音识别
支持剪映和必剪两种ASR引擎，自动将MP4转换为MP3后进行识别
"""

import argparse
import subprocess
import shutil
import os
import sys
import tempfile
from pathlib import Path

# 获取当前脚本的绝对路径，并找到项目根目录
current_script_dir = os.path.dirname(os.path.abspath(__file__))  # 这是cmd目录
project_root_dir = os.path.dirname(current_script_dir)           # 这是项目根目录

# 将根目录添加到模块搜索路径
sys.path.append(project_root_dir) 

# 添加当前目录到Python路径，确保可以导入自定义模块
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

try:
    from app.core.asr import JianYingASR, BcutASR
    from app.core.asr.asr_data import ASRData
except ImportError as e:
    print(f"导入错误: {e}")
    print("请确保ASR模块可用")
    sys.exit(1)

def check_ffmpeg():
    """
    检查系统是否安装了 ffmpeg 和 ffprobe
    """
    def _has(cmd):
        try:
            subprocess.run([cmd, "-version"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
            return True
        except (FileNotFoundError, subprocess.CalledProcessError):
            return False

    if not _has("ffmpeg"):
        print("错误：未找到 ffmpeg，请先安装 ffmpeg 并将其加入 PATH。")
        print("安装参考：https://ffmpeg.org/download.html")
        sys.exit(1)
    if not _has("ffprobe"):
        print("错误：未找到 ffprobe，请先安装 ffmpeg（包含 ffprobe）并将其加入 PATH。")
        sys.exit(1)


def extract_audio_from_video(video_path, audio_path=None):
    """
    使用 FFmpeg 从视频中提取音频并保存为 MP3（最低质量）
    """
    try:
        import subprocess
        import shutil

        check_ffmpeg()

        if audio_path is None:
            temp_dir = tempfile.gettempdir()
            base_name = Path(video_path).stem
            audio_path = os.path.join(temp_dir, f"{base_name}_extracted_audio.mp3")

        print(f"正在从视频提取音频（最低质量）: {video_path} -> {audio_path}")

        # 若目标已存在，先删除以避免 ffmpeg 交互式询问
        if os.path.exists(audio_path):
            os.remove(audio_path)

        # 最低质量参数：8 kbps CBR、单声道、16 kHz、MP3
        cmd = [
            "ffmpeg", "-y", "-i", video_path,
            "-vn",                    # 去除视频流
            "-acodec", "libmp3lame",   # 使用 LAME MP3 编码器
            "-b:a", "10k",             # 恒定码率 8 kbps（最低常用质量）
            "-ar", "16000",           # 采样率 16 kHz
            "-ac", "1",               # 单声道
            "-write_xing", "0",        # 不写 Xing/Info 头（减小体积、避免部分解析器警告）
            audio_path
        ]

        subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)

        if not os.path.exists(audio_path):
            raise Exception("FFmpeg 执行成功但未生成输出文件，请检查输入文件与权限。")

        print(f"音频提取完成: {audio_path}")
        return audio_path

    except subprocess.CalledProcessError as e:
        err_msg = e.stderr.decode("utf-8", errors="ignore") if e.stderr else str(e)
        raise Exception(f"FFmpeg 音频提取失败：{err_msg}") from e
    except Exception as e:
        raise Exception(f"视频转音频失败: {str(e)}")


def is_video_file(file_path):
    """检查文件是否为视频格式"""
    video_extensions = {'.mp4', '.avi', '.mov', '.mkv', '.wmv', '.flv', '.webm', '.m4v'}
    return Path(file_path).suffix.lower() in video_extensions

def is_audio_file(file_path):
    """检查文件是否为音频格式"""
    audio_extensions = {'.mp3', '.wav', '.m4a', '.flac', '.aac', '.ogg', '.wma'}
    return Path(file_path).suffix.lower() in audio_extensions

def main():
    """主函数：处理命令行参数并执行ASR转换"""
    parser = argparse.ArgumentParser(
        description='视频文件语音识别工具 - 自动提取音频后进行识别',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'''
使用示例:
  %(prog)s /sdcard/Videos/video.mp4
  %(prog)s /sdcard/Videos/video.mp4 --engine jianying --format srt
  %(prog)s /sdcard/Videos/video.mp4 -o /sdcard/Output --format both
  %(prog)s /sdcard/Audio/audio.mp3  # 也支持直接处理音频文件
  
支持视频格式: mp4, avi, mov, mkv, wmv, flv, webm, m4v
支持音频格式: mp3, wav, m4a, flac, aac, ogg, wma
        '''
    )
    
    # 必须参数：媒体文件路径
    parser.add_argument(
        'media_file', 
        type=str, 
        help='要处理的视频或音频文件路径'
    )
    
    # 可选参数：输出目录
    parser.add_argument(
        '-o', '--output', 
        type=str, 
        help='输出文件目录（默认与媒体文件同目录）'
    )
    
    # 可选参数：ASR引擎选择
    parser.add_argument(
        '--engine', 
        type=str, 
        choices=['jianying', 'bcut'], 
        default='bcut',
        help='选择ASR引擎：jianying（剪映）或bcut（必剪），默认为bcut'
    )
    
    # 可选参数：输出格式
    parser.add_argument(
        '--format', 
        type=str, 
        choices=['srt','json', 'md', 'all'], 
        default='both',
        help='输出格式：srt、json,md或all，默认为all'
    )
    
    # 可选参数：是否保留临时音频文件
    parser.add_argument(
        '--keep-audio',
        action='store_true',
        help='保留提取的临时音频文件（用于调试）'
    )
    
    # 可选参数：自定义音频输出路径
    parser.add_argument(
        '--audio-output',
        type=str,
        help='指定提取的音频文件保存路径（如不指定则使用临时文件）'
    )
    
    # 可选参数：详细输出
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='详细输出模式'
    )
    
    # 解析命令行参数
    args = parser.parse_args()
    
    # 检查媒体文件是否存在
    if not os.path.exists(args.media_file):
        print(f"错误：媒体文件 '{args.media_file}' 不存在")
        sys.exit(1)
    
    # 确定输出目录
    output_dir = args.output if args.output else os.path.dirname(args.media_file)
    if output_dir == '':
        output_dir = '.'  # 如果媒体文件在当前目录，输出目录设为当前目录
    
    # 确保输出目录存在
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        if args.verbose:
            print(f"创建输出目录: {output_dir}")
    
    # 提取文件名（不含扩展名）
    base_name = os.path.splitext(os.path.basename(args.media_file))[0]
    
    # 处理临时文件
    temp_audio_path = None
    audio_file_to_process = args.media_file
    
    try:
        # 检查文件类型并相应处理
        if is_video_file(args.media_file):
            if args.verbose:
                print(f"检测到视频文件: {args.media_file}")
            
            # 提取音频
            audio_output = args.audio_output
            if audio_output is None and not args.keep_audio:
                # 创建临时文件
                temp_dir = tempfile.gettempdir()
                audio_output = os.path.join(temp_dir, f"{base_name}_temp_{os.getpid()}.mp3")
                temp_audio_path = audio_output
            
            audio_file_to_process = extract_audio_from_video(args.media_file, audio_output)
            
        elif is_audio_file(args.media_file):
            if args.verbose:
                print(f"检测到音频文件: {args.media_file}")
            # 直接使用音频文件
            audio_file_to_process = args.media_file
            
        else:
            print(f"错误：不支持的文件格式 '{args.media_file}'")
            print("请提供视频文件（mp4, avi, mov等）或音频文件（mp3, wav等）")
            sys.exit(1)
        
        if args.verbose:
            print(f"开始处理音频文件: {audio_file_to_process}")
            print(f"使用ASR引擎: {args.engine}")
            print(f"输出目录: {output_dir}")
        
        # 根据选择的引擎初始化ASR
        if args.engine == 'jianying':
            asr = JianYingASR(audio_file_to_process)
        else:  # bcut
            asr = BcutASR(audio_file_to_process)
        
        # 运行语音识别
        if args.verbose:
            print("正在执行语音识别...")
        result = asr.run()
        
        # 根据选择的格式输出文件
        output_files = []
        
        srt_path = os.path.join(output_dir, f"{base_name}.srt")
        result.save(srt_path)
        output_files.append(srt_path)
        if args.verbose:
            print(f"SRT文件已保存至: {srt_path}")
                
        md_path = os.path.join(output_dir, f"{base_name}.md")
        result.save(md_path)
        output_files.append(md_path)
        if args.verbose:
            print(f"MD文件已保存至: {md_path}")
            
        json_path = os.path.join(output_dir, f"srts/{base_name}.json")
        result.save(json_path)
        output_files.append(json_path)
        if args.verbose:
            print(f"JSON文件已保存至: {json_path}")
        
        # 输出成功信息
        print("语音识别处理完成！")
        print(f"生成的输出文件:")
        for file_path in output_files:
            print(f"  - {file_path}")
            
    except Exception as e:
        print(f"处理过程中发生错误：{str(e)}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)
    
    finally:
        # 清理临时文件
        if temp_audio_path and os.path.exists(temp_audio_path) and not args.keep_audio:
            try:
                    os.remove(temp_audio_path)
                    if args.verbose:
                        print(f"已清理临时音频文件: {temp_audio_path}")
            except:
                    pass  # 忽略清理错误

if __name__ == '__main__':
    main()
